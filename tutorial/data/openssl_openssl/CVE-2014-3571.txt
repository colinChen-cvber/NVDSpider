commit 248385c606620b29ecc96ca9d3603463f879652b
Author: Matt Caswell <matt@openssl.org>
Date:   Sat Jan 3 00:54:35 2015 +0000

    Follow on from CVE-2014-3571. This fixes the code that was the original source
    of the crash due to p being NULL. Steve's fix prevents this situation from
    occuring - however this is by no means obvious by looking at the code for
    dtls1_get_record. This fix just makes things look a bit more sane.
    
    Reviewed-by: Dr Stephen Henson <steve@openssl.org>

diff --git a/ssl/d1_pkt.c b/ssl/d1_pkt.c
index 9badc5e3f2..1028e41b56 100644
--- a/ssl/d1_pkt.c
+++ b/ssl/d1_pkt.c
@@ -679,7 +679,8 @@ again:
 		 * would be dropped unnecessarily.
 		 */
 		if (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&
-		    *p == SSL3_MT_CLIENT_HELLO) &&
+		    s->packet_length > DTLS1_RT_HEADER_LENGTH &&
+		    s->packet[DTLS1_RT_HEADER_LENGTH] == SSL3_MT_CLIENT_HELLO) &&
 		    !dtls1_record_replay_check(s, bitmap))
 			{
 			rr->length = 0;

commit feba02f3919495e1b960c33ba849e10e77d0785d
Author: Dr. Stephen Henson <steve@openssl.org>
Date:   Sat Jan 3 00:45:13 2015 +0000

    Fix crash in dtls1_get_record whilst in the listen state where you get two
    separate reads performed - one for the header and one for the body of the
    handshake record.
    
    CVE-2014-3571
    
    Reviewed-by: Matt Caswell <matt@openssl.org>

diff --git a/ssl/d1_pkt.c b/ssl/d1_pkt.c
index 208d244fce..9badc5e3f2 100644
--- a/ssl/d1_pkt.c
+++ b/ssl/d1_pkt.c
@@ -645,8 +645,6 @@ again:
 		/* now s->packet_length == DTLS1_RT_HEADER_LENGTH */
 		i=rr->length;
 		n=ssl3_read_n(s,i,i,1);
-		if (n <= 0) return(n); /* error or non-blocking io */
-
 		/* this packet contained a partial record, dump it */
 		if ( n != i)
 			{
diff --git a/ssl/s3_pkt.c b/ssl/s3_pkt.c
index 2de10d644e..3d8f821f92 100644
--- a/ssl/s3_pkt.c
+++ b/ssl/s3_pkt.c
@@ -197,6 +197,8 @@ int ssl3_read_n(SSL *s, int n, int max, int extend)
 	 * at once (as long as it fits into the buffer). */
 	if (SSL_IS_DTLS(s))
 		{
+		if (left == 0 && extend)
+			return 0;
 		if (left > 0 && n > left)
 			n = left;
 		}
