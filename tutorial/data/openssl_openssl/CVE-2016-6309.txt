commit 44f206aa9dfd4f226f17d9093732dbece5300aa6
Author: Robert Swiecki <swiecki@google.com>
Date:   Sun Sep 25 16:35:56 2016 +0100

    Add to fuzz corpora for CVE-2016-6309
    
    Reviewed-by: Emilia Käsper <emilia@openssl.org>
    Reviewed-by: Matt Caswell <matt@openssl.org>

diff --git a/fuzz/corpora/server/06d05ea3d37abe7554e610be69b743585cb0c6fe b/fuzz/corpora/server/06d05ea3d37abe7554e610be69b743585cb0c6fe
new file mode 100644
index 0000000000..42a535b653
Binary files /dev/null and b/fuzz/corpora/server/06d05ea3d37abe7554e610be69b743585cb0c6fe differ
diff --git a/fuzz/corpora/server/6b008546166c7e1d2ef100eb5ecbac7efe3b3b90 b/fuzz/corpora/server/6b008546166c7e1d2ef100eb5ecbac7efe3b3b90
new file mode 100644
index 0000000000..3b3f140c8e
Binary files /dev/null and b/fuzz/corpora/server/6b008546166c7e1d2ef100eb5ecbac7efe3b3b90 differ
diff --git a/fuzz/corpora/server/f6b0502e2a8a63e84d7b474fad2b2dc127f12bac b/fuzz/corpora/server/f6b0502e2a8a63e84d7b474fad2b2dc127f12bac
new file mode 100644
index 0000000000..abc8c3c262
Binary files /dev/null and b/fuzz/corpora/server/f6b0502e2a8a63e84d7b474fad2b2dc127f12bac differ

commit 0d698f6696e114a6e47f8b75ff88ec81f9e30175
Author: Matt Caswell <matt@openssl.org>
Date:   Fri Sep 23 16:58:11 2016 +0100

    Fix Use After Free for large message sizes
    
    The buffer to receive messages is initialised to 16k. If a message is
    received that is larger than that then the buffer is "realloc'd". This can
    cause the location of the underlying buffer to change. Anything that is
    referring to the old location will be referring to free'd data. In the
    recent commit c1ef7c97 (master) and 4b390b6c (1.1.0) the point in the code
    where the message buffer is grown was changed. However s->init_msg was not
    updated to point at the new location.
    
    CVE-2016-6309
    
    Reviewed-by: Emilia Käsper <emilia@openssl.org>

diff --git a/ssl/statem/statem.c b/ssl/statem/statem.c
index 27dd5d62e5..f00480803c 100644
--- a/ssl/statem/statem.c
+++ b/ssl/statem/statem.c
@@ -445,6 +445,21 @@ static void init_read_state_machine(SSL *s)
     st->read_state = READ_STATE_HEADER;
 }
 
+static int grow_init_buf(SSL *s, size_t size) {
+
+    size_t msg_offset = (char *)s->init_msg - s->init_buf->data;
+
+    if (!BUF_MEM_grow_clean(s->init_buf, (int)size))
+        return 0;
+
+    if (size < msg_offset)
+        return 0;
+
+    s->init_msg = s->init_buf->data + msg_offset;
+
+    return 1;
+}
+
 /*
  * This function implements the sub-state machine when the message flow is in
  * MSG_FLOW_READING. The valid sub-states and transitions are:
@@ -545,9 +560,8 @@ static SUB_STATE_RETURN read_state_machine(SSL *s)
             /* dtls_get_message already did this */
             if (!SSL_IS_DTLS(s)
                     && s->s3->tmp.message_size > 0
-                    && !BUF_MEM_grow_clean(s->init_buf,
-                                           (int)s->s3->tmp.message_size
-                                           + SSL3_HM_HEADER_LENGTH)) {
+                    && !grow_init_buf(s, s->s3->tmp.message_size
+                                         + SSL3_HM_HEADER_LENGTH)) {
                 ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
                 SSLerr(SSL_F_READ_STATE_MACHINE, ERR_R_BUF_LIB);
                 return SUB_STATE_ERROR;
